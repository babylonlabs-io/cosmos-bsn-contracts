{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "Config",
  "description": "Config are Babylon-selectable BTC finality configuration",
  "type": "object",
  "required": [
    "babylon",
    "denom",
    "finality_activation_height",
    "jail_duration",
    "max_active_finality_providers",
    "max_pub_rand_commit_offset",
    "min_pub_rand",
    "missed_blocks_window",
    "reward_interval",
    "staking"
  ],
  "properties": {
    "babylon": {
      "$ref": "#/definitions/Addr"
    },
    "denom": {
      "type": "string"
    },
    "finality_activation_height": {
      "description": "Block height at which the finality module will start to accept finality voting and the minimum allowed value for the public randomness commit start height.",
      "type": "integer",
      "format": "uint64",
      "minimum": 0.0
    },
    "jail_duration": {
      "description": "Minimum period of time in seconds that a finality provider remains jailed (in case of being automatically jailed because of offline detection).",
      "type": "integer",
      "format": "uint64",
      "minimum": 0.0
    },
    "max_active_finality_providers": {
      "description": "Maximum number of active finality providers in the BTC staking protocol.",
      "type": "integer",
      "format": "uint32",
      "minimum": 0.0
    },
    "max_pub_rand_commit_offset": {
      "description": "Maximum number of blocks into the future that a public randomness commitment start height can target. This limit prevents abuse by capping the size of the commitments index, protecting against potential memory exhaustion or performance degradation caused by excessive future commitments.",
      "type": "integer",
      "format": "uint64",
      "minimum": 0.0
    },
    "min_pub_rand": {
      "description": "Minimum amount of public randomness each public randomness commitment should commit.",
      "type": "integer",
      "format": "uint64",
      "minimum": 0.0
    },
    "missed_blocks_window": {
      "description": "Missed number of blocks an FP can be jailed for due to offline detection",
      "type": "integer",
      "format": "uint64",
      "minimum": 0.0
    },
    "reward_interval": {
      "description": "Number of blocks that define the rewards distribution interval",
      "type": "integer",
      "format": "uint64",
      "minimum": 0.0
    },
    "staking": {
      "$ref": "#/definitions/Addr"
    }
  },
  "additionalProperties": false,
  "definitions": {
    "Addr": {
      "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
      "type": "string"
    }
  }
}
