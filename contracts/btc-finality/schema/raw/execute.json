{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "ExecuteMsg",
  "description": "babylon_finality execution handlers",
  "oneOf": [
    {
      "description": "Change the admin",
      "type": "object",
      "required": [
        "update_admin"
      ],
      "properties": {
        "update_admin": {
          "type": "object",
          "properties": {
            "admin": {
              "type": [
                "string",
                "null"
              ]
            }
          },
          "additionalProperties": false
        }
      },
      "additionalProperties": false
    },
    {
      "description": "Set the BTC staking addr. Only admin or the babylon contract can set this",
      "type": "object",
      "required": [
        "update_staking"
      ],
      "properties": {
        "update_staking": {
          "type": "object",
          "required": [
            "staking"
          ],
          "properties": {
            "staking": {
              "type": "string"
            }
          },
          "additionalProperties": false
        }
      },
      "additionalProperties": false
    },
    {
      "description": "Committing a sequence of public randomness for EOTS",
      "type": "object",
      "required": [
        "commit_public_randomness"
      ],
      "properties": {
        "commit_public_randomness": {
          "type": "object",
          "required": [
            "commitment",
            "fp_pubkey_hex",
            "num_pub_rand",
            "signature",
            "start_height"
          ],
          "properties": {
            "commitment": {
              "description": "Commitment of these public randomness values. Currently, it's the root of the Merkle tree that includes the public randomness",
              "allOf": [
                {
                  "$ref": "#/definitions/Binary"
                }
              ]
            },
            "fp_pubkey_hex": {
              "description": "BTC PK of the finality provider that commits the public randomness",
              "type": "string"
            },
            "num_pub_rand": {
              "description": "Amount of public randomness committed",
              "type": "integer",
              "format": "uint64",
              "minimum": 0.0
            },
            "signature": {
              "description": "Signature on (start_height || num_pub_rand || commitment) signed by the SK corresponding to `fp_pubkey_hex`. This prevents others committing public randomness on behalf of `fp_pubkey_hex`",
              "allOf": [
                {
                  "$ref": "#/definitions/Binary"
                }
              ]
            },
            "start_height": {
              "description": "Start block height of the list of public randomness",
              "type": "integer",
              "format": "uint64",
              "minimum": 0.0
            }
          },
          "additionalProperties": false
        }
      },
      "additionalProperties": false
    },
    {
      "description": "Submit Finality Signature.\n\nThis is a message that can be called by a finality provider to submit their finality signature to the Consumer chain. The signature is verified by the Consumer chain using the finality provider's public key\n\nThis message is equivalent to the `MsgAddFinalitySig` message in the Babylon finality protobuf defs.",
      "type": "object",
      "required": [
        "submit_finality_signature"
      ],
      "properties": {
        "submit_finality_signature": {
          "type": "object",
          "required": [
            "block_hash",
            "fp_pubkey_hex",
            "height",
            "proof",
            "pub_rand",
            "signature"
          ],
          "properties": {
            "block_hash": {
              "$ref": "#/definitions/Binary"
            },
            "fp_pubkey_hex": {
              "type": "string"
            },
            "height": {
              "type": "integer",
              "format": "uint64",
              "minimum": 0.0
            },
            "proof": {
              "$ref": "#/definitions/Proof"
            },
            "pub_rand": {
              "$ref": "#/definitions/Binary"
            },
            "signature": {
              "$ref": "#/definitions/Binary"
            }
          },
          "additionalProperties": false
        }
      },
      "additionalProperties": false
    },
    {
      "description": "Unjails finality provider. Admin can unjail anyone anytime, others can unjail only themselves, and only if the jail period passed.",
      "type": "object",
      "required": [
        "unjail"
      ],
      "properties": {
        "unjail": {
          "type": "object",
          "required": [
            "fp_pubkey_hex"
          ],
          "properties": {
            "fp_pubkey_hex": {
              "description": "FP to unjail",
              "type": "string"
            }
          },
          "additionalProperties": false
        }
      },
      "additionalProperties": false
    },
    {
      "description": "Update the contract configuration. Only admin can update the config. All fields are optional - only non-empty ones will be updated.",
      "type": "object",
      "required": [
        "update_config"
      ],
      "properties": {
        "update_config": {
          "type": "object",
          "properties": {
            "finality_activation_height": {
              "description": "Block height at which the finality module will start to accept finality voting",
              "type": [
                "integer",
                "null"
              ],
              "format": "uint64",
              "minimum": 0.0
            },
            "jail_duration": {
              "description": "Minimum period of time in seconds that a finality provider remains jailed",
              "type": [
                "integer",
                "null"
              ],
              "format": "uint64",
              "minimum": 0.0
            },
            "max_active_finality_providers": {
              "description": "Maximum number of active finality providers in the BTC staking protocol.",
              "type": [
                "integer",
                "null"
              ],
              "format": "uint32",
              "minimum": 0.0
            },
            "max_pub_rand_commit_offset": {
              "description": "Maximum number of blocks into the future that a public randomness commitment start height can target",
              "type": [
                "integer",
                "null"
              ],
              "format": "uint64",
              "minimum": 0.0
            },
            "min_pub_rand": {
              "description": "Minimum amount of public randomness each public randomness commitment should commit.",
              "type": [
                "integer",
                "null"
              ],
              "format": "uint64",
              "minimum": 0.0
            },
            "missed_blocks_window": {
              "description": "Missed number of blocks an FP can be jailed for due to offline detection",
              "type": [
                "integer",
                "null"
              ],
              "format": "uint64",
              "minimum": 0.0
            },
            "reward_interval": {
              "description": "Number of blocks that define the rewards distribution interval",
              "type": [
                "integer",
                "null"
              ],
              "format": "uint64",
              "minimum": 0.0
            }
          },
          "additionalProperties": false
        }
      },
      "additionalProperties": false
    }
  ],
  "definitions": {
    "Binary": {
      "description": "Binary is a wrapper around Vec<u8> to add base64 de/serialization with serde. It also adds some helper methods to help encode inline.\n\nThis is only needed as serde-json-{core,wasm} has a horrible encoding for Vec<u8>. See also <https://github.com/CosmWasm/cosmwasm/blob/main/docs/MESSAGE_TYPES.md>.",
      "type": "string"
    },
    "Proof": {
      "description": "Proof represents a Merkle proof. NOTE: The convention for proofs is to include leaf hashes but to exclude the root hash. This convention is implemented across IAVL range proofs as well. Keep this consistent unless there's a very good reason to change everything.  This also affects the generalized proof system as well.\n\nhttps://github.com/cometbft/cometbft/blob/d03254d3599b973f979314e6383b89fa1802e679/crypto/merkle/proof.go#L26",
      "type": "object",
      "required": [
        "aunts",
        "index",
        "leaf_hash",
        "total"
      ],
      "properties": {
        "aunts": {
          "description": "Hashes from leaf's sibling to a root's child.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/Binary"
          }
        },
        "index": {
          "description": "Index of item to prove.",
          "type": "integer",
          "format": "uint64",
          "minimum": 0.0
        },
        "leaf_hash": {
          "description": "Hash of item value.",
          "allOf": [
            {
              "$ref": "#/definitions/Binary"
            }
          ]
        },
        "total": {
          "description": "Total number of items.",
          "type": "integer",
          "format": "uint64",
          "minimum": 0.0
        }
      },
      "additionalProperties": false
    }
  }
}
