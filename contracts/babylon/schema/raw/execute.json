{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "ExecuteMsg",
  "oneOf": [
    {
      "description": "Slashing event from the BTC staking contract.\n\nThis will be forwarded over IBC to the Babylon side for propagation to other Consumers, and Babylon itself",
      "type": "object",
      "required": [
        "slashing"
      ],
      "properties": {
        "slashing": {
          "type": "object",
          "required": [
            "evidence"
          ],
          "properties": {
            "evidence": {
              "$ref": "#/definitions/Evidence"
            }
          },
          "additionalProperties": false
        }
      },
      "additionalProperties": false
    },
    {
      "description": "Message sent by the finality contract, to send rewards to distribute to Babylon Genesis",
      "type": "object",
      "required": [
        "distribute_rewards"
      ],
      "properties": {
        "distribute_rewards": {
          "type": "object",
          "required": [
            "fp_distribution"
          ],
          "properties": {
            "fp_distribution": {
              "description": "List of finality providers and their rewards",
              "type": "array",
              "items": {
                "$ref": "#/definitions/RewardInfo"
              }
            }
          },
          "additionalProperties": false
        }
      },
      "additionalProperties": false
    }
  ],
  "definitions": {
    "Evidence": {
      "description": "Evidence is the evidence that a finality provider has signed finality signatures with correct public randomness on two conflicting Babylon headers",
      "type": "object",
      "required": [
        "block_height",
        "canonical_app_hash",
        "canonical_finality_sig",
        "fork_app_hash",
        "fork_finality_sig",
        "fp_btc_pk",
        "pub_rand",
        "signing_context"
      ],
      "properties": {
        "block_height": {
          "description": "Height of the conflicting blocks",
          "type": "integer",
          "format": "uint64",
          "minimum": 0.0
        },
        "canonical_app_hash": {
          "description": "AppHash of the canonical block",
          "type": "array",
          "items": {
            "type": "integer",
            "format": "uint8",
            "minimum": 0.0
          }
        },
        "canonical_finality_sig": {
          "description": "Finality signature to the canonical block, where finality signature is an EOTS signature, i.e., the `s` in a Schnorr signature `(r, s)`. `r` is the public randomness already committed by the finality provider. Deserializes to `SchnorrEOTSSig`",
          "type": "array",
          "items": {
            "type": "integer",
            "format": "uint8",
            "minimum": 0.0
          }
        },
        "fork_app_hash": {
          "description": "AppHash of the fork block",
          "type": "array",
          "items": {
            "type": "integer",
            "format": "uint8",
            "minimum": 0.0
          }
        },
        "fork_finality_sig": {
          "description": "Finality signature to the fork block, where finality signature is an EOTS signature. Deserializes to `SchnorrEOTSSig`",
          "type": "array",
          "items": {
            "type": "integer",
            "format": "uint8",
            "minimum": 0.0
          }
        },
        "fp_btc_pk": {
          "description": "BTC PK of the finality provider that casts this vote",
          "type": "array",
          "items": {
            "type": "integer",
            "format": "uint8",
            "minimum": 0.0
          }
        },
        "pub_rand": {
          "description": "Public randomness the finality provider has committed to. Deserializes to `SchnorrPubRand`",
          "type": "array",
          "items": {
            "type": "integer",
            "format": "uint8",
            "minimum": 0.0
          }
        },
        "signing_context": {
          "description": "Context in which the finality signatures were used. It must be hex encoded 32 bytes, of the sha256 hash of the context string",
          "type": "string"
        }
      },
      "additionalProperties": false
    },
    "RewardInfo": {
      "type": "object",
      "required": [
        "fp_pubkey_hex",
        "reward"
      ],
      "properties": {
        "fp_pubkey_hex": {
          "type": "string"
        },
        "reward": {
          "$ref": "#/definitions/Uint128"
        }
      },
      "additionalProperties": false
    },
    "Uint128": {
      "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
      "type": "string"
    }
  }
}
